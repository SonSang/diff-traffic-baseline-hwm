void v_basicLight(float4 position  : POSITION,
                  float3 normal    : NORMAL,

                  out float4 oPosition : POSITION,
                  out float4 color     : COLOR,

                  uniform float4x4 modelViewProj,
                  uniform float3 globalAmbient,
                  uniform float3 lightColor,
                  uniform float3 lightPosition,
                  uniform float3 eyePosition,
                  uniform float3 Ke,
                  uniform float3 Ka,
                  uniform float3 Kd,
                  uniform float3 Ks,
                  uniform float  shininess)
{
  oPosition = mul(modelViewProj, position);

  float3 P = position.xyz;
  float3 N = normal;

  // Compute the emissive term
  float3 emissive = Ke;

  // Compute the ambient term
  float3 ambient = Ka * globalAmbient;

  // Compute the diffuse term
  float3 L = normalize(lightPosition - P);
  float diffuseLight = max(dot(N, L), 0);
  float3 diffuse = Kd * lightColor * diffuseLight;

  // Compute the specular term
  float3 V = normalize(eyePosition - P);
  float3 H = normalize(L + V);
  float specularLight = pow(max(dot(N, H), 0),
                            shininess);

  if (diffuseLight <= 0) specularLight = 0;
  float3 specular = Ks * lightColor * specularLight;

  color.xyz = emissive + ambient + diffuse + specular;

  color.w = 1;
}

void v_dir_basicLight(float4 position  : POSITION,
                  float3 normal    : NORMAL,

                  out float4 oPosition : POSITION,
                  out float4 color     : COLOR,

                  uniform float4x4 modelViewProj,
                  uniform float3 globalAmbient,
                  uniform float3 lightColor,
                      uniform float3 lightDirection,
                  uniform float3 eyePosition,
                  uniform float3 Ke,
                  uniform float3 Ka,
                  uniform float3 Kd,
                  uniform float3 Ks,
                  uniform float  shininess)
{
  oPosition = mul(modelViewProj, position);

  float3 P = position.xyz;
  float3 N = normal;

  // Compute the emissive term
  float3 emissive = Ke;

  // Compute the ambient term
  float3 ambient = Ka * globalAmbient;

  // Compute the diffuse term
  float3 L = -lightDirection;
  float diffuseLight = max(dot(N, L), 0);
  float3 diffuse = Kd * lightColor * diffuseLight;

  // Compute the specular term
  float3 V = normalize(eyePosition - P);
  float3 H = normalize(L + V);
  float specularLight = pow(max(dot(N, H), 0),
                            shininess);

  if (diffuseLight <= 0) specularLight = 0;
  float3 specular = Ks * lightColor * specularLight;

  color.xyz = emissive + ambient + diffuse + specular;

  color.w = 1;
}

void v_fragmentLighting(float4 position : POSITION,
                        float3 normal   : NORMAL,
                        out float4 oPosition : POSITION,
                        out float3 objectPos : TEXCOORD0,
                        out float3 oNormal   : TEXCOORD1,
                        uniform float4x4 modelViewProj)
{
  oPosition = mul(modelViewProj, position);
  objectPos = position.xyz;
  oNormal   = normal;
}

void f_basicLight(float4 position  : TEXCOORD0,
                  float3 normal    : TEXCOORD1,
                  out float4 color     : COLOR,
                  uniform float3 globalAmbient,
                  uniform float3 lightColor,
                  uniform float3 lightPosition,
                  uniform float3 eyePosition,
                  uniform float3 Ke,
                  uniform float3 Ka,
                  uniform float3 Kd,
                  uniform float3 Ks,
                  uniform float  shininess)
{
  float3 P = position.xyz;
  float3 N = normalize(normal);

  // Compute the emissive term
  float3 emissive = Ke;

  // Compute the ambient term
  float3 ambient = Ka * globalAmbient;

  // Compute the diffuse term
  float3 L = normalize(lightPosition - P);
  float diffuseLight = max(dot(N, L),0);
  float3 diffuse = Kd * lightColor * diffuseLight;

  // Compute the specular term
  float3 V = normalize(eyePosition - P);
  float3 H = normalize(L + V);
  float specularLight = pow(max(dot(N, H),0),
                            shininess);

  if (diffuseLight <= 0) specularLight = 0;
  float3 specular = Ks * lightColor * specularLight;

  color.xyz = emissive + ambient + diffuse + specular;
  color.w = 1;
}

void f_dir_basicLight(float4 position  : TEXCOORD0,
                      float3 normal    : TEXCOORD1,
                      out float4 color     : COLOR,
                      uniform float3 globalAmbient,
                      uniform float3 lightColor,
                      uniform float3 lightDirection,
                      uniform float3 eyePosition,
                      uniform float3 Ke,
                      uniform float3 Ka,
                      uniform float3 Kd,
                      uniform float3 Ks,
                      uniform float  shininess)
{
  float3 P = position.xyz;
  float3 N = normalize(normal);

  // Compute the emissive term
  float3 emissive = Ke;

  // Compute the ambient term
  float3 ambient = Ka * globalAmbient;

  // Compute the diffuse term
  float3 L = -lightDirection;
  float diffuseLight = max(dot(N, L),0);
  float3 diffuse = Kd * lightColor * diffuseLight;

  // Compute the specular term
  float3 V = normalize(eyePosition - P);
  float3 H = normalize(L + V);
  float specularLight = pow(max(dot(N, H),0),
                            shininess);

  if (diffuseLight <= 0) specularLight = 0;
  float3 specular = Ks * lightColor * specularLight;

  color.xyz = emissive + ambient + diffuse + specular;
  color.w = 1;
}

void v_fragmentLighting_ref(float4 position : POSITION,
                            float3 normal   : NORMAL,
                            out float4 oPosition : POSITION,
                            out float3 objectPos : TEXCOORD0,
                            out float3 oNormal   : TEXCOORD1,
                            out float3 R         : TEXCOORD2,

                            uniform float3   eyePositionW,
                            uniform float4x4 modelToWorld,
                            uniform float4x4 modelViewProj)
{
    oPosition = mul(modelViewProj, position);
    objectPos = position.xyz;
    oNormal   = normal;

    // Compute position and normal in world space

    float3 positionW = mul(modelToWorld, position).xyz;
    float3 N = mul((float3x3)modelToWorld, normal);
    N = normalize(N);

    // Compute the incident and reflected vectors
    float3 I = positionW - eyePositionW;
    R = reflect(I, N);
}


void f_dir_basicLight_ref(float4 position  : TEXCOORD0,
                          float3 normal    : TEXCOORD1,
                          float3 R         : TEXCOORD2,

                          out float4 color     : COLOR,
                          uniform float3 globalAmbient,
                          uniform float3 lightColor,
                          uniform float3 lightDirection,
                          uniform float3 eyePosition,
                          uniform float3 Ke,
                          uniform float3 Ka,
                          uniform float3 Kd,
                          uniform float3 Ks,
                          uniform float  shininess,
                          uniform float reflectivity,
                          samplerCUBE envMap :register(s0))
{
  float3 P = position.xyz;
  float3 N = normalize(normal);

  // Compute the emissive term
  float3 emissive = Ke;

  // Compute the ambient term
  float3 ambient = Ka * globalAmbient;

  // Compute the diffuse term
  float3 L = -lightDirection;
  float diffuseLight = max(dot(N, L),0);
  float3 diffuse = Kd * lightColor * diffuseLight;

  // Compute the specular term
  float3 V = normalize(eyePosition - P);
  float3 H = normalize(L + V);
  float specularLight = pow(max(dot(N, H),0),
                            shininess);

  if (diffuseLight <= 0) specularLight = 0;
  float3 specular = Ks * lightColor * specularLight;

  // Fetch reflected environment color
  float3 reflectedColor = texCUBE(envMap, R).xyz;

  float3 litcolor = emissive + ambient + diffuse + specular;

  color.xyz = lerp(litcolor, reflectedColor, reflectivity);

  color.w = 1;

}

void v_reflection(float4  position : POSITION,
                  float3 normal : NORMAL,

                  out float4 oPosition : POSITION,
                  out float3 R         : TEXCOORD0,

                  uniform float3   eyePositionW,
                  uniform float4x4 modelViewProj,
                  uniform float4x4 modelToWorld)
{
    oPosition = mul(modelViewProj, position);

    // Compute position and normal in world space

    float3 positionW = mul(modelToWorld, position).xyz;
    float3 N = mul((float3x3)modelToWorld, normal);
    N = normalize(N);

    // Compute the incident and reflected vectors

    float3 I = positionW - eyePositionW;
    R = reflect(I, N);
}

void  f_reflection(float3 R        : TEXCOORD0,
                   out float4 color : COLOR,

                   uniform float reflectivity,
                   samplerCUBE envMap :register(s0))
{
   // Fetch reflected environment color
   float4 reflectedColor = texCUBE(envMap, R);

   // Fetch the decal base color
   float4 decalColor = 0.5;

   color = lerp(decalColor, reflectedColor, reflectivity);
}

